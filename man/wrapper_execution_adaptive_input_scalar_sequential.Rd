% Generated by roxygen2: do not edit by hand
% Please edit documentation in
%   R/2_2_3_a__engine_execution_adaptive_input_scalar_sequential__mwiller.R
\name{wrapper_execution_adaptive_input_scalar_sequential}
\alias{wrapper_execution_adaptive_input_scalar_sequential}
\title{Wrapper for Execution Engine: Adaptive Scalar Param Optimization (Sequential)}
\usage{
wrapper_execution_adaptive_input_scalar_sequential(control, split_output)
}
\arguments{
\item{control}{A standardized control object.}

\item{split_output}{A list with at least one split, of which the first is used.}
}
\value{
A standardized execution output object.
}
\description{
Optimizes a single numeric/scalar hyperparameter in sequential steps.
In each iteration, the value is updated and \code{run_workflow_singlesplitloop()} is called with the adjusted \code{control} object.
The process stops when the performance metric no longer improves sufficiently, or when the maximum number of steps is reached.
}
\details{
\strong{Standardized Inputs:}
\itemize{
\item \code{control}: Full control object.
\item \code{split_output}: Output of the splitter engine. Only the \strong{first split} is used for all runs.
\item \code{control$params$execution$params}: Engine-specific settings.
}

\strong{Engine-Specific Parameters (\code{control$params$execution$params}):}
\itemize{
\item \code{param_path} \emph{(character)}: Path to the scalar parameter to optimize (e.g., \code{"train_params$n.trees"}).
\item \code{param_start} \emph{(numeric)}: Starting value of the parameter.
\item \code{param_step} \emph{(numeric)}: Increment to apply in each iteration.
\item \code{direction} \emph{(character)}: Either \code{"minimize"} or \code{"maximize"} the metric.
\item \code{metric_name} \emph{(character)}: Metric to monitor.
\item \code{metric_source} \emph{(character)}: ID of the evaluation engine returning the metric.
\item \code{min_improvement} \emph{(numeric)}: Minimum required improvement to continue.
\item \code{max_iterations} \emph{(integer â‰¥ 1)}: Maximum number of optimization steps.
}

\strong{Example Control Snippet:}

\if{html}{\out{<div class="sourceCode">}}\preformatted{control$engine_select$execution <- "execution_adaptive_input_scalar_sequential"
control$params$execution <- controller_execution(
  params = list(
    param_path = "train_params$n.trees",
    param_start = 10,
    param_step = 10,
    direction = "minimize",
    metric_name = "mse",
    metric_source = "eval_mse",
    min_improvement = 0.001,
    max_iterations = 10
  )
)
}\if{html}{\out{</div>}}

\strong{Template Reference:}
See \verb{inst/templates_control/2_3_a_template_execution_adaptive_input_scalar_sequential.R}

\strong{Standardized Output (returned to framework):}
Created via \code{initialize_output_execution()}:
\itemize{
\item \code{execution_type}: \code{"adaptive_input_scalar_sequential"}
\item \code{workflow_results}: List of results per parameter value
\item \code{params}: Final execution parameter list
\item \code{continue_workflow}: Always \code{TRUE}
\item \code{specific_output}: Includes:
\itemize{
\item \code{metric_name}, \code{metric_source}
\item \code{values}: Vector of metric values
\item \code{param_values}: Tested parameter values
\item \code{best_metric}: Best metric value
\item \code{best_param}: Corresponding best parameter value
\item \code{best_result}: Full result object from best run
}
}
}
\seealso{
\code{\link[=engine_execution_adaptive_input_scalar_sequential]{engine_execution_adaptive_input_scalar_sequential()}},
\code{\link[=default_params_execution_adaptive_input_scalar_sequential]{default_params_execution_adaptive_input_scalar_sequential()}},
\code{\link[=initialize_output_execution]{initialize_output_execution()}},
\code{\link[=controller_execution]{controller_execution()}},
Template: \verb{inst/templates_control/2_3_a_template_execution_adaptive_input_scalar_sequential.R}
}
\keyword{internal}
