---
title: "In Detail: Engines - Execution"
subtitle: "Execution strategies for running workflow components"
author: "mwiller"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{In Detail: Engines - Execution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

> **Summary**  
> This vignette documents the family of **execution engines**.  
> It covers how different execution strategies (sequential, parallel, cluster-based) are structured, how they interact with splitters and other engines, and how results are merged into a unified workflow output.

---

Execution Engines in `flowengineR` orchestrate the application of models over multiple data splits. They define **how** and **where** model training and evaluation are carried out ‚Äî sequentially, in parallel, or deferred to external systems like SLURM. Each of the listed execution engines below defines a distinct way to repeatedly call `run_workflow_singlesplitloop()` on one or more splits. Some execute all splits directly, others submit them to external systems, and a few (adaptive engines) decide at runtime how many splits or parameter configurations to evaluate.

They represent one of the most flexible and extensible components of the framework.

---

## üì• Standardized Inputs (via Wrapper)
Passed via `wrapper_execution_*()` and automatically pre-filled by the framework:


| Input           | Type      | Description                                                                 |
|----------------|-----------|-----------------------------------------------------------------------------|
| `control`       | list      | Full control object (‚ö†Ô∏è provided directly by the workflow)             |
| `split_output`  | list      | Output from splitter engine, containing multiple `train`/`test` splits (‚ö†Ô∏è provided directly by the workflow)       |
| `params`        | list      | Engine-specific execution parameters from `controller_execution()`         |

Framework resolution:
- `params`: from `control$params$execution$params`

---

## üì§ Standardized Output (via Wrapper)
Returned via `initialize_output_execution()`:

| Output              | Type         | Description                                                                   |
|---------------------|--------------|-------------------------------------------------------------------------------|
| `execution_type`    | character    | Name of execution engine used                                                 |
| `workflow_results`  | list/null    | List of results from model executions (or `NULL` for deferred workflows)      |
| `params`            | list         | Parameters used (merged defaults and user-specified)                          |
| `continue_workflow` | logical      | Should downstream engines be triggered (`TRUE`) or is manual continuation needed? |
| `specific_output`   | list/null    | Optional metadata (e.g. registry path, number of jobs)                        |

---

## üîÑ Adaptive Execution: Stability Monitoring

Some execution engines, such as `execution_adaptive_output_sequential`, are designed to run `run_workflow_singlesplitloop()` multiple times **until a monitored metric stabilizes**. They generate one split at a time, execute the model, and evaluate a metric (e.g. MSE) using a stability strategy (e.g. Cohen's d, standard deviation).

These engines require:
- Splitters that return only **one split at a time**
- Definitions of monitored metric, strategy, threshold, and window size
- Control over loop iterations via min/max number of splits

To assess stability, they use strategy functions such as `check_stability_cohen_absolute()`, `check_stability_sd_relative()`, etc., which follow a common interface:

```r
check_stability_xxx(values, threshold, window, fun = NULL)
```

These helpers return a list with elements like `is_stable`, `stability_value`, and `threshold_value`.

---

## üîß Adaptive Execution: Hyperparameter Optimization
Other engines like `execution_adaptive_input_scalar_sequential` focus on **scalar hyperparameter optimization**. These iterate over parameter values (e.g. number of trees), run a workflow per value, and evaluate performance based on a defined metric. Execution stops when improvements become negligible or a maximum number of steps is reached.

Key elements:
- Path to the parameter in the control object (`param_path`)
- Start value, step size, and optimization direction (minimize/maximize)
- Metric source and threshold for improvement

This strategy is ideal for lightweight and interpretable tuning of a single hyperparameter in scenarios with high model cost.

---

## ‚öôÔ∏è Available Execution Engines

Below is an overview of all execution engines included in `flowengineR`, including a short description and path to the corresponding template.

| Engine Name                                      | Function Name                                             | Description                                     | Template Path                                                                            | Detail Page |
|--------------------------------------------------|-----------------------------------------------------------|-------------------------------------------------|------------------------------------------------------------------------------------------|-------------|
| `execution_basic_sequential`                     | `engine_execution_basic_sequential()`                     | Simple sequential execution loop                | `inst/templates_control/2_1_a_template_control_execution_basic_sequential.R`             | [üìÑ](detail_engine_execution_basic_sequential.html) |
| `execution_basic_slurm_array`                    | `engine_execution_basic_slurm_array()`                    | Prepare SLURM input for external execution      | `inst/templates_control/2_1_b_template_control_execution_basic_slurm_array.R`            | [üìÑ](detail_engine_execution_basic_slurm_array.html) |
| `execution_basic_batchtools_local`               | `engine_execution_basic_batchtools_local()`               | Local batchtools backend execution              | `inst/templates_control/2_1_c_template_control_execution_basic_batchtools_local.R`       | [üìÑ](detail_engine_execution_basic_batchtools_local.html) |
| `execution_basic_batchtools_multicore`           | `engine_execution_basic_batchtools_multicore()`           | Parallel execution using multicore backend      | `inst/templates_control/2_1_d_template_control_execution_basic_batchtools_multicore.R`   | [üìÑ](detail_engine_execution_basic_batchtools_multicore.html) |
| `execution_basic_batchtools_slurm`               | `engine_execution_basic_batchtools_slurm()`               | Parallel execution via SLURM backend            | `inst/templates_control/2_1_e_template_control_execution_basic_batchtools_slurm.R`       | [üìÑ](detail_engine_execution_basic_batchtools_slurm.html) |
| `execution_adaptive_output_sequential`           | `engine_execution_adaptive_output_sequential()`           | Adaptive execution until metric stabilizes      | `inst/templates_control/2_2_a_template_execution_adaptive_output_sequential.R`           | [üìÑ](detail_engine_execution_adaptive_output_sequential.html) |
| `execution_adaptive_output_batchtools_multicore` | `engine_execution_adaptive_output_batchtools_multicore()` | Adaptive metric stabilization via multicore     | `inst/templates_control/2_2_b_template_execution_adaptive_output_batchtools_multicore.R` | [üìÑ](detail_engine_execution_adaptive_output_batchtools_multicore.html) |
| `execution_adaptive_output_batchtools_slurm`     | `engine_execution_adaptive_output_batchtools_slurm()`     | Adaptive metric stabilization via SLURM         | `inst/templates_control/2_2_c_template_execution_adaptive_output_batchtools_slurm.R`     | [üìÑ](detail_engine_execution_adaptive_output_batchtools_slurm.html) |
| `execution_adaptive_input_scalar_sequential`     | `engine_execution_adaptive_input_scalar_sequential()`     | Sequential scalar hyperparameter optimization   | `inst/templates_control/2_3_a_template_execution_adaptive_input_scalar_sequential.R`     | [üìÑ](detail_engine_execution_adaptive_input_scalar_sequential.html) |

Use `list_registered_engines("execution")` to inspect all currently loaded splitter engines.

---

## üß© Engine Usage *in* Workflow

To use an execution engine, configure it within your control object:

```r
control$engine_select$execution <- "execution_basic_sequential"
control$params$execution <- controller_execution(
  params = list()  # optional parameters
)
```
You can use any of the registered engines shown above, or create your own.

---

## üîÅ Resuming After External Execution

Some engines such as `execution_basic_slurm_array` prepare the workflow for deferred execution outside of R (e.g. SLURM).

These engines write `control` and `split_output` to disk and expect external systems to return the corresponding `workflow_results`.

To continue the workflow afterward, use the controller `controller_resume_execution()` in combination with `resume_workflow()`:

```r
workflow_results <- readRDS("slurm_outputs/workflow_results.rds")
resume_object <- controller_resume_execution(
  control = control,
  split_output = split_output,
  workflow_results = workflow_results,
  metadata = list(slurm_job_id = "batch123")
)
result <- resume_workflow(resume_object)
```

Only the final stages (e.g., reporting and publishing) will be executed. Evaluation and postprocessing are expected to have been handled externally.

---

## üõ†Ô∏è Writing Your Own Execution Engine

1. Write a wrapper `wrapper_execution_*()` with the standardized input/output interface.
2. Wrap internal engine logic in an `engine_execution_*()` function.
3. Use `initialize_output_execution()` to return results in a uniform format.
4. (Optional) Define default parameters with `default_params_execution_*()`.

You may implement engines that:
- run models sequentially or in parallel
- distribute computation to clusters or cloud environments
- defer execution and trigger manual resumption later (e.g. SLURM)

---

## üîç Further Reading

- [`run_workflow_singlesplitloop()`](reference/run_workflow_singlesplitloop.html): internal function used to process individual splits.
- [`prepare_resume_from_slurm_array()`](reference/prepare_resume_from_slurm_array.html): utility to continue SLURM-based execution.
- [`initialize_output_execution()`](reference/initialize_output_execution.html): creates standardized wrapper output.
- Templates and defaults in `inst/templates_control/2_1_*/`
